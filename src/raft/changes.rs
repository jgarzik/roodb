//! Row change types for Raft replication
//!
//! These types represent the row-level changes generated by SQL DML operations
//! that need to be replicated through Raft consensus.

use serde::{Deserialize, Serialize};

/// The type of change operation
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum ChangeOp {
    /// Insert a new row
    Insert,
    /// Update an existing row
    Update,
    /// Delete a row
    Delete,
}

/// A single row change to be replicated
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct RowChange {
    /// Table name (including "system." prefix for system tables)
    pub table: String,
    /// Encoded row key
    pub key: Vec<u8>,
    /// Encoded row value (None for DELETE)
    pub value: Option<Vec<u8>>,
    /// Type of change
    pub op: ChangeOp,
}

impl RowChange {
    /// Create an INSERT change
    pub fn insert(table: impl Into<String>, key: Vec<u8>, value: Vec<u8>) -> Self {
        Self {
            table: table.into(),
            key,
            value: Some(value),
            op: ChangeOp::Insert,
        }
    }

    /// Create an UPDATE change
    pub fn update(table: impl Into<String>, key: Vec<u8>, value: Vec<u8>) -> Self {
        Self {
            table: table.into(),
            key,
            value: Some(value),
            op: ChangeOp::Update,
        }
    }

    /// Create a DELETE change
    pub fn delete(table: impl Into<String>, key: Vec<u8>) -> Self {
        Self {
            table: table.into(),
            key,
            value: None,
            op: ChangeOp::Delete,
        }
    }

    /// Create a DELETE change with value included for tracking
    ///
    /// Used for system table deletes where the row data is needed to identify
    /// what table/index is being dropped (for catalog rebuild in apply()).
    pub fn delete_with_value(table: impl Into<String>, key: Vec<u8>, value: Vec<u8>) -> Self {
        Self {
            table: table.into(),
            key,
            value: Some(value),
            op: ChangeOp::Delete,
        }
    }

    /// Check if this is a system table change
    pub fn is_system_change(&self) -> bool {
        self.table.starts_with("system.")
    }
}

/// A set of row changes from a single transaction
///
/// When the executor completes a DML operation, it produces a ChangeSet
/// that is then proposed to Raft for consensus and replication.
#[derive(Debug, Clone, Default, PartialEq, Eq, Serialize, Deserialize)]
pub struct ChangeSet {
    /// Transaction ID that produced these changes
    pub txn_id: u64,
    /// The row-level changes
    pub changes: Vec<RowChange>,
}

impl ChangeSet {
    /// Create a new empty change set
    pub fn new(txn_id: u64) -> Self {
        Self {
            txn_id,
            changes: Vec::new(),
        }
    }

    /// Create a change set with pre-populated changes
    pub fn new_with_changes(txn_id: u64, changes: Vec<RowChange>) -> Self {
        Self { txn_id, changes }
    }

    /// Add a change to the set
    pub fn push(&mut self, change: RowChange) {
        self.changes.push(change);
    }

    /// Check if the change set is empty
    pub fn is_empty(&self) -> bool {
        self.changes.is_empty()
    }

    /// Get the number of changes
    pub fn len(&self) -> usize {
        self.changes.len()
    }

    /// Take ownership of the changes
    pub fn into_changes(self) -> Vec<RowChange> {
        self.changes
    }

    /// Iterate over the changes
    pub fn iter(&self) -> impl Iterator<Item = &RowChange> {
        self.changes.iter()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_row_change_insert() {
        let change = RowChange::insert("users", vec![1, 2, 3], vec![4, 5, 6]);
        assert_eq!(change.table, "users");
        assert_eq!(change.op, ChangeOp::Insert);
        assert!(change.value.is_some());
        assert!(!change.is_system_change());
    }

    #[test]
    fn test_row_change_delete() {
        let change = RowChange::delete("users", vec![1, 2, 3]);
        assert_eq!(change.op, ChangeOp::Delete);
        assert!(change.value.is_none());
    }

    #[test]
    fn test_system_change() {
        let change = RowChange::insert("system.tables", vec![1], vec![2]);
        assert!(change.is_system_change());
    }

    #[test]
    fn test_change_set() {
        let mut cs = ChangeSet::new(42);
        assert!(cs.is_empty());

        cs.push(RowChange::insert("users", vec![1], vec![2]));
        cs.push(RowChange::delete("users", vec![3]));

        assert_eq!(cs.len(), 2);
        assert_eq!(cs.txn_id, 42);
    }

    #[test]
    fn test_serialization() {
        let change = RowChange::insert("users", vec![1, 2], vec![3, 4]);
        let serialized = bincode::serialize(&change).unwrap();
        let deserialized: RowChange = bincode::deserialize(&serialized).unwrap();

        assert_eq!(change.table, deserialized.table);
        assert_eq!(change.key, deserialized.key);
        assert_eq!(change.value, deserialized.value);
        assert_eq!(change.op, deserialized.op);
    }

    #[test]
    fn test_changeset_serialization() {
        let mut cs = ChangeSet::new(123);
        cs.push(RowChange::insert("users", vec![1], vec![2]));
        cs.push(RowChange::update("users", vec![3], vec![4]));

        let serialized = bincode::serialize(&cs).unwrap();
        let deserialized: ChangeSet = bincode::deserialize(&serialized).unwrap();

        assert_eq!(cs.txn_id, deserialized.txn_id);
        assert_eq!(cs.len(), deserialized.len());
    }
}
